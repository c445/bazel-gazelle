/* Copyright 2018 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repos

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/internal/label"
)

type module struct {
	Path, Version string
	Main          bool
	Replace       *module
}

func importRepoRulesModules(filename string) (repos []Repo, err error) {
	tempDir, err := copyGoModToTemp(filename)
	if err != nil {
		return nil, err
	}
	defer os.RemoveAll(tempDir)

	data, err := goListModulesFn(tempDir)
	if err != nil {
		return nil, err
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	for dec.More() {
		var mod module
		if err := dec.Decode(&mod); err != nil {
			return nil, err
		}
		if mod.Main {
			continue
		}

		repo := label.ImportPathToBazelRepoName(mod.Path)

		remote, version := "", mod.Version
		if mod.Replace != nil {
			hasPrefix := func(s string) bool { return strings.HasPrefix(mod.Replace.Path, s) }
			if hasPrefix("/") || hasPrefix("./") || hasPrefix("../") {
				log.Printf("gazelle: ignore path replacement %s => %s; add a local_repository rule with name=%q to your WORKSPACE", mod.Path, mod.Replace.Path, repo)
				continue
			}

			// Populate version and remote of replacement.
			remote = "https://" + mod.Replace.Path
			version = mod.Replace.Version
		}

		var tag, commit string
		if strings.HasPrefix(version, "v0.0.0-") {
			if i := strings.LastIndex(version, "-"); i < 0 {
				return nil, fmt.Errorf("failed to parse version for %s: %q", mod.Path, version)
			} else {
				commit = version[i+1:]
			}
		} else {
			tag = version
		}
		repos = append(repos, Repo{
			Name:     repo,
			GoPrefix: mod.Path,
			Commit:   commit,
			Tag:      tag,
			Remote:   remote,
		})
	}

	return repos, nil
}

// goListModulesFn may be overridden by tests.
var goListModulesFn = goListModules

// goListModules invokes "go list" in a directory containing a go.mod file.
func goListModules(dir string) ([]byte, error) {
	goTool := findGoTool()
	cmd := exec.Command(goTool, "list", "-m", "-json", "all")
	cmd.Stderr = os.Stderr
	cmd.Dir = dir
	data, err := cmd.Output()
	return data, err
}

// copyGoModToTemp copies to given go.mod file to a temporary directory.
// go list tends to mutate go.mod files, but gazelle shouldn't do that.
func copyGoModToTemp(filename string) (tempDir string, err error) {
	goModOrig, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer goModOrig.Close()

	tempDir, err = ioutil.TempDir("", "gazelle-temp-gomod")
	if err != nil {
		return "", err
	}

	goModCopy, err := os.Create(filepath.Join(tempDir, "go.mod"))
	if err != nil {
		os.Remove(tempDir)
		return "", err
	}
	defer func() {
		if cerr := goModCopy.Close(); err == nil && cerr != nil {
			err = cerr
		}
	}()

	_, err = io.Copy(goModCopy, goModOrig)
	if err != nil {
		os.RemoveAll(tempDir)
		return "", err
	}
	return tempDir, err
}

// findGoTool attempts to locate the go executable. If GOROOT is set, we'll
// prefer the one in there; otherwise, we'll rely on PATH. If the wrapper
// script generated by the gazelle rule is invoked by Bazel, it will set
// GOROOT to the configured SDK. We don't want to rely on the host SDK in
// that situation.
func findGoTool() string {
	path := "go" // rely on PATH by default
	if goroot, ok := os.LookupEnv("GOROOT"); ok {
		path = filepath.Join(goroot, "bin", "go")
	}
	if runtime.GOOS == "windows" {
		path += ".exe"
	}
	return path
}
